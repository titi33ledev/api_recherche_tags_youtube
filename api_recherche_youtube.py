# -*- coding: utf-8 -*-
"""API_recherche_youtube.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u0RvZXiEtuN9IkMwy3zRopM-kJrKesLR

# Analyse de la popularitÃ© des vidÃ©os
Nous allons utiliser l'API de YouTube pour extraire les donnÃ©es de plusieurs vidÃ©os. En utilisant ces donnÃ©es, nous allons visualiser et comparer la **popularitÃ© des vidÃ©os** en fonction de leur nombre de **vues**, de **likes**.

*RÃ©alisÃ© par [Tidiane Hubert](https://www.linkedin.com/in/tidianehubert/)*
"""

#@title Initialisation âš™ï¸
#@markdown Vous n'avez rien Ã  faire, juste lancer la cellule pour que le bot s'initialise ðŸš€

!pip install --upgrade google-api-python-client &> /dev/null
!pip install --upgrade google-auth-oauthlib google-auth-httplib2 &> /dev/null
!pip install ural
!pip install git+https://github.com/ClaudeCoulombe/FrenchLefffLemmatizer.git
!pip install pelote &> /dev/null
!yes | pip install ipysigma --quiet


import googleapiclient.discovery
import json
import pandas as pd
import nltk
from nltk.stem.snowball import FrenchStemmer
from french_lefff_lemmatizer.french_lefff_lemmatizer import FrenchLefffLemmatizer
import pelote
from ipysigma import Sigma
from google.colab import output
output.enable_custom_widget_manager()
from ural import get_domain_name, is_shortened_url, is_url, should_follow_href

"""**Obtenir une clÃ© API de YouTube**"""

#@title ðŸ›  ParamÃ¨trage OK ðŸ› 
# @markdown ## 1. Performances ðŸš¨
# @markdown Et oui, c'est ***GRATUIT.*** Donc amusez vous. ðŸ˜Š

api_keys = 000

youtube = googleapiclient.discovery.build(
    "youtube",
    "v3",
    developerKey=api_keys)


with open("/content/cle_api_google.txt", "r") as f:
  read_api_key = f.readlines()
  api_key = read_api_key[0].strip()

#@title *On met tout en place, un peu de patience* ðŸ¤©

mot_cle = "laver ses chaussure"#@param {type:"string"}

request = youtube.search().list(
    q=mot_cle,
    part="snippet",
    channelType="any",
    maxResults=50
)
search = request.execute()
search = pd.json_normalize(search["items"])

search_id_video = search["id.videoId"]
search_id_video_liste = list(search_id_video)
search_id_video_liste

#RÃ©cupÃ©rer les ID VidÃ©os
request = youtube.search().list(
        part="id",
        channelId=api_key,
        type="video",
        maxResults=50
        )
response = request.execute()

# Extraire les ID des vidÃ©os
video_ids = [item['id']['videoId'] for item in response['items']]

#RÃ©cupÃ©rer les informations de toutes les vidÃ©os
request = youtube.videos().list(
     part = 'snippet',
     id = search_id_video_liste
     )

response = request.execute()
info_video = pd.json_normalize(response["items"])

liste_info_video = list(info_video["snippet.tags"])

df = pd.DataFrame()
df["tags"] = pd.DataFrame(info_video["snippet.tags"])

"""Processing des **donnÃ©es**"""

#@title *Allez on rassemble tout* ðŸ¤©

def graphing(tokens):
  links = list()

  for i in range(len(tokens)-1):
    links.append(
        {
            "source":tokens[i],
            "target":tokens[i+1:]
        }
    )

  nodes = {"id":tokens}

  return nodes, links

def crawl_to_sem_graph(df):
  links = []
  nodes = []

  for tags in df["tags"]:
    if isinstance(tags, list):
      result = graphing(tags)
      nodes.append(result[0])
      links += result[1]

  df_nodes = pd.DataFrame(nodes)
  df_nodes = df_nodes.explode("id")
  df_nodes["count"] = 1
  df_nodes = df_nodes.groupby("id").sum().reset_index()

  df_links = pd.DataFrame(links)
  df_links = df_links.explode("target")
  df_links["weight"] = 1
  df_links = df_links.groupby(["source", "target"]).sum().reset_index()

  return df_nodes, df_links

df_nodes, df_links = crawl_to_sem_graph(df)

#@title *Visualisation des donnÃ©es* ðŸ¤©


G = pelote.tables_to_graph(
    df_nodes, df_links, node_col="id", node_data=["count"], edge_data=["weight"]
)

sigma = Sigma(
    G,
    node_size="count",
    node_size_range=[3, 30],

    node_metrics={'category': 'louvain'},
    node_color="category",
    node_color_gradient = "Sinebow",

    node_label_size = G.degree,
    node_label_size_range = (8, 16),
    node_label_color = "#FFFFFF",

    default_edge_type="curve",
    #background_color ="black",
    start_layout=True,
    height=720
)

sigma